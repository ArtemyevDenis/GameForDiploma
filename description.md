## Содержание

- [Аннотация](#1-Аннотация)
- [Классы состояния](#2-Классы_состояния)
- [Класс порта](#3-Класс_порта)
- [Функция main](#4-Функция_main)
- [Приложение А](#5-Приложение_А)
-------------------------------
<h2 id="1-Аннотация"> Аннотация</h2>
Данный код показывает пример работы с последовательным портом на языке программирования Python. Данный код реализует обработку возможных ошибок при помощи пользовательского класса State, а также непосредственно управление последовательным портом через пользовательский класс Port, который наследуется от класса Serial из библиотеки serial. 

-------------------------------

<h2 id="2-Классы_состояния"> Классы состояния</h2>
Для обработки ошибок в данном коде используется пользовательский класс State, который наследуется от встроенного в Python класса Exception. Порт может быть в двух сотояниях: ошибки нет и ошибка есть. Данные состояния реализуют классы Ok и Error, которые наследуются от класса State (рис.1).

<p align="center">
    <img alt = state_classes src = images/state_classes.png>
    <br>
        <em>Рис.1. Диаграмма классов состояния</em>
</p>

Ниже представлена реализация класса State
```
class State(Exception):
    operation = ''
    def __repr__(self):
        try:
            return f'State(lastcmd="{self.lastcmd}", exception="{self.exception}")'
        except:
            return f'State(lastcmd="{self.lastcmd}")'
```
Как видно класс имеет следующие поля:

- _Operation_ – переменная строкового типа, которая содержит в себе последнюю операцию. Инициализируется, как пустая строка.

Так же класс State имеет метод:

- _repr_ - функция которая формирует строку состояния. В данной функции есть блок try-except для корректной работы программы, а именно, если нет исключений, то функция вернёт строку, содержащую последнюю команду и наименования исключения, а если исключение есть, то функция вернёт строку, содержащую только последнюю команду. Входные данные – отсутствуют, выходные данные – строка.

Реализация класса Ok выглядит следующим образом
```
class Ok(State):
    def __init__(self, lastcmd):
        self.operation = lastcmd
```
Класс Ok имеет следующие методы

- _init_- это конструктор класса Ok, который принимает последнюю команду и записывает её в поле operation, который был создан в классе State.

Реализация класса Error вынлядит следующим образом

```
class Error(State):
    def __init__(self, lastcmd, exception):
        self.operation = lastcmd
        self.exception = exception
```

Класс Error имеет следующие методы:

- _init_ - это конструктор класса Error, который принимает последнюю команду(lastcmd) и записывает её в поле operation, а также принимает исключение(exception) и записывает его в поле exception.

----------------------------------------

<h2 id="3-Класс_порта"> Класс порта</h2>

Ниже представлена реализация класса Port
```
class Port(Serial):

    def __init__(self, port='/dev/ttyUSB0'):
        try:
            super().__init__(port, baudrate=115200)
            self.state = State()
        except SerialException as e:
            self.state = Error('', e)
            print(self.state, file=sys.stderr)
            exit(2)

    def G00(self, j1=0, j2=0, j3=0, j4=0, j5=0, j6=0):
        try:
            cmd = f'G00 J1={j1} J2={j2} J3={j3} J4={j4} J5={j5} J6={j6}\r\n'
            print(f'>> {cmd.strip()}', file=sys.stderr)
            self.write(bytes(cmd,'ascii'))
            self.state = Ok(cmd)
        except Exception as e:
            self.state = Error(cmd, e)

    def set_speed(self, vp=50):
        try:
            cmd = f'G07 VP={vp}\r\n'
            print(f'>> {cmd.strip()}', file=sys.stderr)
            self.write(bytes(cmd,'ascii'))
            self.state = Ok(cmd)
            assert self.is_ready()
        except Exception as e:
            self.state = Error(cmd, e)

    def is_ready(self, timeout=10000):
        try:
            n = 0
            while 1:
                n += 1
                assert n < timeout, f'The timeout of {timeout / 1000} seconds was exceeded when performing operation {self.state.operation}'
                x = self.read_all().decode('ascii').strip()
                if x: print(f'<< {x}', file=sys.stderr)
                if '%' in x:
                    break
                sleep(0.001)
        except Exception as e:
            self.state = Error(self.state.operation, e)
            raise self.state
```
Данный класс имеет следующие методы: init, G00, set_speed, is_ready.

**_init_** - Конструктор класса Port. Конструктор принимает строку port, которая содержит расположение порта, к которму было подключено устройство. Данная функция имеет блок try-except, В случае, когда исключений нет:
 - С помощью функции super() вызывается конструктор класса Serial, который является родительским для класса Port, с параметрами port и baudrate=115200. Переменная port была получена как агрумент, а baudrate – перемнная, которая отвечает за скорость передачи данных, в данном случае, она равняется 115200 бит в секунду.
 - Создается пустая перемнная типа State и записывается в поле state.

В случае, когда есть икслючение типа SerialException: 
 - Создается перменная типа Error, где поле lastcmd - пустое, а поле exception – e (перемнная, в которыую было записано пойманное исключение).  Перменная типа Error записывается в поле state. 
 - Информация о пойманном исключении (self.state) выводится в стандартный поток ощибок (sys.stderr).
 - Программа завершается с кодом 2.

**_G00_** - Функция перемещения инструмента по указанным координатам. Данный метод принимает 6 перменных (j1-j6) типа int, если переданных прееменных меньше, например были переданы только j1 и j2, то остальные имеют значение 0.

Данная функция имеет блок try-except. В случае, когда исключения нет: 

- Создается перменная cmd, в которую записывается строка в формате “G00 J1=<значение j1> J2=<значение j2> J3 =<значение j3> J4=<значение j4> J5=<значение j5> J6=<значение j6>\r\n”. Команда G00 отвечает за быстрое пермещение инструмента или рабочей головки в указанные координаты (J1-J6). В конце строки присутствует перенос на новую строку - \r\n.
- В перменной cmd убираются все пробелы в начале и в конце, с помощью функции strip(). Полученная строка выводится в стандартный поток ошибок. 
- Строка cmd перведоится в последовательность байтов при помощи команды bytes() и кодировки ASCII. Затем полученная последовательность отправляется в последовательный порт с помощью функции write().
- Создается переменная типа Ok, у которой последняя команда - cmd. Данная переменная записывается в поле state.

В случае возникновения исключения типа Exception:
- Создается переменная типа Error,у которой последняя команда – cmd и исключение – e(перменная в которую было записано пойманное исключение). Данная переменная записывается в поле state.

 **_set_speed_** - Функция назначения корости передвижения инструмента в мм/мин. Она принимает целочисленную пременную vp, которая по умолчанию равна 50. 
 Данная функция имеет блок try-except. В случае, когда исключений нет: 

- Создается перменная cmd, в которую записывается строка в формате “G07 VP=<значение vp>r\n”. Команда G07 отвечает за установку скорости перемещения инструмента. Переменная vp отвечает непосредственно за значение скорости в мм/мин. В конце строки присутствует перенос на новую строку - \r\n.
- В перменной cmd убираются все пробелы в начале и в конце, с помощью функции strip(). Полученная строка выводится в стандартный поток ошибок. 
- Строка cmd перведоится в последовательность байтов при помощи команды bytes() и кодировки ASCII. Затем полученная последовательность отправляется в последовательный порт с помощью функции write().
- Создается переменная типа Ok, у которой последняя команда - cmd. Данная переменная записывается в поле state.
- Проверяется, готов ли объект типа Port к выполнению следующей операции, для этого вызывается метод класса Port is_ready(). Если порт не готво, то создаётся исключение AssertError.

В случае возникновения исключения типа Exception:
- Создается переменная типа Error,у которой последняя команда – cmd и исключение – e(перменная в которую было записано пойманное исключение). Данная переменная записывается в поле state.

**_is_ready_** - Фнукция проверк иготвоности порта к выполнению следующей команды. Данный метод принисает целое число timeout, по умолчанию равное 10000 (10 секунд). 
Данная функция имеет конструкцию try-except. В случае, когда нет исключений: 

- Создаётся целочисленная перменная n равная 0.
- Запускается бесконечный цикл.
    - n увеличивается на единицу.
    - Проверяется, что n меньше timeout, если n больше или равен timeout, создается исключение AssertionError, с сообщением, что время выполнения операции превысило 10 секунд.
    - Создаётся строковая перменная x, в которую записываются все доступные данные из последовательного порта в виде байтовой последовательности. Затем они декодируются с помощью кодировки ASCII, и удаляются все пробелы в начале и конце строки.
    - В случае, когда перменная x непсутая, она выводится в стандартный поток ошибок.
    - Если в строке x есть %, то цикл завершается.
    - Остановка выполнения программы на 0.001 секунды.

В случае, когда есть исключение типа Exception:
- Создается переменная типа Error,у которой последняя команда – cmd и исключение – e(перменная в которую было записано пойманное исключение). Данная переменная записывается в поле state.
- Исключение передаётся на уровень выше, где была вызвана функция is_ready().
---------------------------------------------
<h2 id="4-Функция_main">Функция main</h2>

Ниже представлен код функции main 
```
if __name__ == '__main__':
    p = Port()
    p.set_speed(1)
    p.set_speed(100)
    p.set_speed(75)
    p.G00(j5=115550, j4=113.5, j6=-90)
    p.is_ready()
    p.G00(j1=152, j5=115550*2, j4=113.5, j6=-90)
    p.is_ready()
    # p.G00(j5=115550)
    # p.is_ready()
    p.G00()
    p.is_ready()
```
Данная функция

- Создаёт пустую перемнную p типа Port.
- Устанавливается скорость предвижения устройства – 1 мм/мин.
- Устанавливается скорость предвижения устройства – 100 мм/мин.
- Устанавливается скорость предвижения устройства – 100 мм/мин.
- Устройство перемещается по координатам (0;0;0;113.5;115550;-90).
- Проверяется готовность порта к новым командам.
- Устройство перемещается по координатам (152;0;0;113.5;115550*2;-90).
- Проверяется готовность порта к новым командам.
- Устройство перемещается по координатам (0;0;0;0;0;0).
- Проверяется готовность порта к новым командам.
---------------------------------------------------
<h2 id="5-Приложение_А">Приложение А. Полный код программы</h2>

```
import sys

from serial import Serial 
from serial.serialutil import SerialException
from time import sleep

class State(Exception):
    operation = ''

    def __repr__(self):
        try:
            return f'State(lastcmd="{self.lastcmd}", exception="{self.exception}")'
        except:
            return f'State(lastcmd="{self.lastcmd}")'

class Ok(State):
    def __init__(self, lastcmd):
        self.operation = lastcmd

class Error(State):
    def __init__(self, lastcmd, exception):
        self.operation = lastcmd
        self.exception = exception

class Port(Serial):

    def __init__(self, port='/dev/ttyUSB0'):
        try:
            super().__init__(port, baudrate=115200)
            self.state = State()
        except SerialException as e:
            self.state = Error('', e)
            print(self.state, file=sys.stderr)
            exit(2)

    def G00(self, j1=0, j2=0, j3=0, j4=0, j5=0, j6=0):
        try:
            cmd = f'G00 J1={j1} J2={j2} J3={j3} J4={j4} J5={j5} J6={j6}\r\n'
            print(f'>> {cmd.strip()}', file=sys.stderr)
            self.write(bytes(cmd,'ascii'))
            self.state = Ok(cmd)
        except Exception as e:
            self.state = Error(cmd, e)

    def set_speed(self, vp=50):
        try:
            cmd = f'G07 VP={vp}\r\n'
            print(f'>> {cmd.strip()}', file=sys.stderr)
            self.write(bytes(cmd,'ascii'))
            self.state = Ok(cmd)
            assert self.is_ready()
        except Exception as e:
            self.state = Error(cmd, e)

    def is_ready(self, timeout=10000):
        try:
            n = 0
            while 1:
                n += 1
                assert n < timeout, f'The timeout of {timeout / 1000} seconds was exceeded when performing operation {self.state.operation}'
                x = self.read_all().decode('ascii').strip()
                if x: print(f'<< {x}', file=sys.stderr)
                if '%' in x:
                    break
                sleep(0.001)
        except Exception as e:
            self.state = Error(self.state.operation, e)
            raise self.state

if __name__ == '__main__':
    p = Port()
    p.set_speed(1)
    p.set_speed(100)
    p.set_speed(75)
    p.G00(j5=115550, j4=113.5, j6=-90)
    p.is_ready()
    p.G00(j1=152, j5=115550*2, j4=113.5, j6=-90)
    p.is_ready()
    # p.G00(j5=115550)
    # p.is_ready()
    p.G00()
    p.is_ready()
```
